<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>主定理(Master Theorem)笔记</title>
      <link href="/2018/03/03/%E4%B8%BB%E5%AE%9A%E7%90%86%E6%B5%85%E8%B0%88/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;算法导论的 Chapter_4 之 Master Theorem<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="Master-Theorem的用途"><a href="#Master-Theorem的用途" class="headerlink" title="Master Theorem的用途"></a>Master Theorem的用途</h2><p>&emsp;&emsp;简单地说，主定理是用来解一类<a href="https://zh.wikipedia.org/wiki/%E9%81%9E%E8%BF%B4%E9%97%9C%E4%BF%82%E5%BC%8F" target="_blank" rel="noopener">递归方程</a>的，这类递归方程形如：<br>$$<br>    T(n) = aT(n/b) + f(n)&emsp;(a&gt;=1,b&gt;1)<br>$$<br>&emsp;&emsp;在算法导论的4.4里也介绍了一种叫<a href="https://www.jianshu.com/p/b6ceccbce5ff" target="_blank" rel="noopener">递归树法</a>的方法解递归方程，但是主定理提供的是一种更快的方法，按书上的说法甚至可以口算出来。</p><h2 id="如何找出递归方程"><a href="#如何找出递归方程" class="headerlink" title="如何找出递归方程"></a>如何找出递归方程</h2><p>&emsp;&emsp;举个书上的例子：<br><figure class="image-box">                <img src="deemo1.jpg" alt="在72页的一个伪代码" title="" class="">                <p>在72页的一个伪代码</p>            </figure><br>&emsp;&emsp;先关注调用自身的第4行和第5行：在第4行中，调用函数时传递的参数是一个长度为原来一半的数组（原来数组的左半段），所以这个子问题花费的时间就是 $T(n/2)$ ，第5行也同理，所以就得出公式中 $b=2$ ;所以4、5两行加起来就是 $2T(n/2)$ ，也就是 $a=2$ 。<br>&emsp;&emsp;再看剩下的几行，据书上说的，第6行的那个函数是花费 $\theta(n)$ ,而其他的都是花费 $\theta(1)$ ,所以全部加起来的话就是 $f(n) = \theta(n)$ 了。<br>&emsp;&emsp;也就是这个函数的递归方程为：<br>$$<br>    T(n) = 2T(n/2) + \theta(n)<br>$$<br>&emsp;&emsp;简化一点来说的话，$a$就是函数调用本身的次数，$b$就是子问题的长度，$f(n)$就是剩下的步骤花费的时间。<br><figure class="image-box">                <img src="deemo2.jpg" alt="书上的解析，在第73页" title="" class="">                <p>书上的解析，在第73页</p>            </figure></p><h1 id="Master-Theorem的内容"><a href="#Master-Theorem的内容" class="headerlink" title="Master Theorem的内容"></a>Master Theorem的内容</h1><p>&emsp;&emsp;其实就是分三种情况：<br>&emsp;&emsp;对于递归方程<br>$$<br>    T(n) = aT(n/b) + f(n)&emsp;(a≥1,b&gt;1)<br>$$</p><ul><li>Case 1:<br>&emsp;&emsp;如果$f(n) = O(n^{log_{b}a - \epsilon})$&emsp;($\epsilon$是常数且$\epsilon&gt;0$)，那么就会有$T(n) = \theta(n^{log_ba})$</li><li>Case 2:<br>&emsp;&emsp;如果$f(n) = \theta(n^{log_{b}a})$，就有 $T(n) = \theta(n^{log_ba}lgn)$ </li><li>Case 3:<br>&emsp;&emsp;如果$n$足够大时，存在常数$c$使得$af(n/b)≤cf(n)$，且$f(n) = \Omega(n^{log_{b}a + \epsilon})$ &emsp;($\epsilon$是常数且$\epsilon&gt;0$)，就有$T(n) = \theta(f(n))$</li></ul><blockquote><p>&emsp;&emsp;作者：“实际上就是有点像分类讨论的大于、等于、小于的三种情况”</p></blockquote><h2 id="举几个例子"><a href="#举几个例子" class="headerlink" title="举几个例子"></a>举几个例子</h2><ul><li><p>$T(n) = 9T(n/3) + n$<br>此时，有$f(n) = n$且$n^{log_ba}=n^{log_39}=n^2$，当 $\epsilon≤1$时(书上取了$1$)，就有$f(n)=O(n^{log_39-\epsilon})$，所以符合Case 1。于是代入公式就得到：<br>$$<br>  T(n) = \theta(n^{log_39}) = \theta(n^2)<br>$$</p></li><li><p>$T(n)=3T(n/4)+nlgn$<br>此时，$f(n) = nlgn$且$n^{log_ba}=n^{log_43}=O(n^{0.793})$，当取$\epsilon≤0.2$时(书上取了$\epsilon≈0.2$)，就有Caes 3中的$f(n) = \omega(n^{log_{b}a + \epsilon})$；又当取$c=3/4$时，就有$af(n/b)=3(n/4)lg(n/4)≤(3/4)nlgn=cf(n)$，所以符合Case 3。代入公式得：<br>$$<br>  T(n) = \theta(n^{log_43}) = \theta(nlgn)<br>$$</p></li><li><p>$T(n)=2T(n/2)+\theta(n)$<br>此时，就有$n^{log_ba}=n^{log_22}=n=\theta(n)=f(n)$，符合Case 2。于是<br>$$<br>  T(n) = \theta(nlgn)<br>$$</p></li><li><p>特殊例子：$T(n)=2T(n/2)+nlgn$<br>在这个例子中，可以得到$n^{log_ba}=n^{log_22}=n$，$f(n)=nlgn$，很接近Case 3，但是我们不能取得一个$\epsilon&gt;0$使得$nlgn = \Omega(n^{1 + \epsilon})$，所以是不符合Case 3的(实际上是在Case 2和Case 3之间)，主定理不适用于这种情况，要解的话可以用其他方法(比如递归树法)。</p></li></ul><h2 id="关于-epsilon"><a href="#关于-epsilon" class="headerlink" title="关于$\epsilon$"></a>关于$\epsilon$</h2><p>&emsp;&emsp;首先$\epsilon$是要大于0的，它的作用是保证Case 1中左式的阶低于右式的阶(就是书上说的”polynomially smaller”)、Case 3中左式的阶高于右式的阶。关于“渐进性态”、“阶”之类的如果不懂的话这里有一篇<a href="http://www.gocalf.com/blog/algorithm-complexity-and-master-theorem.html" target="_blank" rel="noopener">挺好的文章</a><br>&emsp;&emsp;举个反例，如果不加$\epsilon$的话：<br>&emsp;&emsp;这样的话Case 1的条件就变成了：$f(n) = O(n^{log_{b}a})$；Case 3变成了：$f(n) = \Omega(n^{log_{b}a})$。<br>&emsp;&emsp;那么当$a=b$且$f(n)=n$时，$n=O(n)$，$n=\theta(n)$，$n=\Omega(n)$这三种情况都成立，就会造成一种混淆。</p><blockquote><p>&emsp;&emsp;作者：“我想出来的而已，不保证正确。”</p></blockquote><h2 id="关于Case-3的-af-n-b-≤cf-n"><a href="#关于Case-3的-af-n-b-≤cf-n" class="headerlink" title="关于Case 3的$af(n/b)≤cf(n)$"></a>关于Case 3的$af(n/b)≤cf(n)$</h2><p>&emsp;&emsp;关于这个式子，书上只是说它是一个规律(“regularity”，感觉没有详细说，可能是我看不到)，参考了<a href="https://math.stackexchange.com/questions/510897/why-does-afn-b-le-cfn-for-c-1-imply-that-fn-omegan-log-ba-e" target="_blank" rel="noopener">网上的说法</a>后，发现它是可以推出$f(n) = \Omega(n^{log_{b}a + \epsilon})$的(前方式子较多)：<br>&emsp;&emsp;首先它的式子是这样的：<br>$$<br>    af(n/b)≤cf(n)&emsp;(c&lt;1)<br>$$<br>&emsp;&emsp;令$\alpha=a/c$，再移一下项，得到：<br>$$<br>    \alpha f(n/b)≤f(n)<br>$$<br>&emsp;&emsp;然后用$bn$代替$n$，得到：<br>$$<br>    \alpha f(n)≤f(bn)<br>$$<br>&emsp;&emsp;两边乘$\alpha$，然后用$bn$代替$n$，得到：<br>$$<br>    \alpha^2 f(n)≤f(b^2n)<br>$$<br>&emsp;&emsp;结合两式：<br>$$<br>    \alpha^2 f(n/b)≤\alpha f(n)≤f(bn)<br>$$<br>&emsp;&emsp;用$bn$代替$n$，就得到：<br>$$<br>    \alpha^2 f(n)≤f(b^2n)<br>$$<br>&emsp;&emsp;一直重复，就有：<br>$$<br>    \alpha^i f(n)≤f(b^in)<br>$$<br>&emsp;&emsp;取$n=1$：<br>$$<br>    \alpha^i f(1)≤f(b^i)<br>$$<br>&emsp;&emsp;此时令$n=b^i$的话，就有$i=log_bn$，于是把$i$代入得：<br>$$<br>    \alpha^{log_bn} f(1)≤f(n)<br>$$<br>&emsp;&emsp;由一条和换底相关的公式得到$\alpha^{log_bn} = n^{log_b\alpha}$，又因为$c&lt;1$，所以$\alpha = a/c &gt; a$，所以有$log_b \alpha &gt; log_ba$，这里就可以把$\epsilon$代进去：$log_b \alpha = log_ba + \epsilon$，最后把$\alpha^{log_bn} = n^{log_ba + \epsilon}$代进去，就有：<br>$$<br>    n^{log_ba + \epsilon} f(1)≤f(n)<br>$$<br>&emsp;&emsp;因为$f(1) = \theta(1)$，所以就得到：<br>$$<br>    f(n) = \theta(n^{log_ba + \epsilon})<br>$$</p><blockquote><p>&emsp;&emsp;作者：“也许也是方便后面的缩放吧- -”</p></blockquote><h1 id="Master-Theorem的证明"><a href="#Master-Theorem的证明" class="headerlink" title="Master Theorem的证明"></a>Master Theorem的证明</h1><p>&emsp;&emsp;对主定理的证明，书上给了三个步骤(或三个引理”Lemma”)：</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p>&emsp;&emsp;第一步就是先找出总开销，首先看看书上99页的递归树：<br><figure class="image-box">                <img src="deemo3.jpg" alt="看着这个图的话感觉会比较好理解" title="" class="">                <p>看着这个图的话感觉会比较好理解</p>            </figure><br>&emsp;&emsp;我们可以把这棵树分成两部分：根(枝)和叶，根据公式$T(n) = aT(n/b) + f(n)$可以得到枝的第$i$层的开销是$a^if(n/b^i)$；每一个叶子节点的开销是$\theta(1)$(叶子就是到递归结束那里了)。<br><br>&emsp;&emsp;对于枝，总的开销就是把每一层的开销加起来。<br>$$<br>    af(n/b)+a^2f(n/b^2)+…+a^{log_bn-1}f(n/b^{log_bn-1}) = \sum_{j=0}^{log_bn-1} a^jf(n/b^j)<br>$$<br>&emsp;&emsp;对于叶，因为树的高度是$log_bn$，所以叶子的总个数是$a^{log_bn}$(在一层中，每一条枝都分出$a$条枝)，也就是$n^{log_ba}$，因为每一个叶子的开销是$\theta(1)$，所以叶子的总开销是叶子树乘每个的开销，就是：<br>$$<br>    \theta(n^{log_ba})<br>$$<br>&emsp;&emsp;最后把枝和叶的总开销加起来，得到：<br><figure class="image-box">                <img src="deemo4.jpg" alt="这个的证明书上说得也挺详细的了" title="" class="">                <p>这个的证明书上说得也挺详细的了</p>            </figure></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p>&emsp;&emsp;我们需要对第一步中得到的公式化简一下，需要化简的是公式右边的积分(令它为$g(n)$):<br>$$<br>    g(n) = \sum_{j=0}^{log_bn-1} a^jf(n/b^j)<br>$$</p><h3 id="Case-1"><a href="#Case-1" class="headerlink" title="Case 1:"></a>Case 1:</h3><p>&emsp;&emsp;在Case 1中，因为有$f(n)=O(n^{log_{b}a-\epsilon})$，所以用$n/b^j$代$n$就得到了$f(n/b^j)=O((n/b^j)^{log_{b}a-\epsilon})$，整个代入$g(n)$，就有：<br>$$<br>    g(n) = O(\sum_{j=0}^{log_bn-1} a^j(n/b^j)^{log_{b}a-\epsilon})<br>$$<br>&emsp;&emsp;然后就是对这个公式的化简：<br><figure class="image-box">                <img src="deemo5.jpg" alt="“中间有个等比数列求和”" title="" class="">                <p>“中间有个等比数列求和”</p>            </figure><br>&emsp;&emsp;因为$b$和$\epsilon$都是常数，所以$(n^{\epsilon}-1)/(b^{\epsilon}-1) = O(n^{\epsilon})$，所以有：<br>$$<br>    g(n) = n^{log_ba-\epsilon}O(n^{\epsilon}) = O(n^{log_ba})<br>$$</p><h3 id="Case-2"><a href="#Case-2" class="headerlink" title="Case 2:"></a>Case 2:</h3><p>&emsp;&emsp;同样地，在Case 2中，因为$f(n)=\theta(n^{log_{b}a})$，用$n/b^j$代$n$，得到$f(n/b^j)=\theta((n/b^j)^{log_{b}a})$，代入$g(n)$中，就有：<br>$$<br>    g(n) = \theta (\sum_{j=0}^{log_bn-1} a^j(n/b^j)^{log_{b}a})<br>$$<br>&emsp;&emsp;同样化简公式：<br><figure class="image-box">                <img src="deemo6.jpg" alt="" title="" class="">                <p></p>            </figure><br>&emsp;&emsp;然后代入$g(n)$得到结果：<br>$$<br>    g(n) = \theta(n^{log_ba}log_bn) = \theta(n^{log_ba}lgn)<br>$$</p><h3 id="Case-3"><a href="#Case-3" class="headerlink" title="Case 3:"></a>Case 3:</h3><p>&emsp;&emsp;Case 3有一点不一样，因为它有一个条件$af(n/b)≤cf(n)$，所以可以用一下放缩，首先由这个条件可以进一步得到$a^jf(n/b^j)≤c^jf(n)$，然后就代入公式来一个放缩，然后化简：</p><blockquote><p>&emsp;&emsp;作者：“按书上说的就是先移项得到$f(n/b)≤(c/a)f(n)$，然后再迭代一下：$f(n/b^2)≤(c/a)f(n/b)≤(c/a)^2f(n)$，一直这样迭代就得到：$f(n/b^i)≤(c/a)^if(n)$，再移项一下就得到那个式子了。”</p></blockquote><figure class="image-box">                <img src="deemo7.jpg" alt="放缩法- -" title="" class="">                <p>放缩法- -</p>            </figure><p>&emsp;&emsp;据一位大佬说的，加个$O(n)$是为了保证另外一个条件：$n$足够大。<br>&emsp;&emsp;(书上说)因为$c$是常数，所以最后也可以变为：<br>$$<br>    g(n)=\theta(f(n))<br>$$</p><blockquote><p>&emsp;&emsp;作者：“我认为的话就是：既然当$j=0$时(根)都有$f(n)$了，那$g(n)=\Omega(f(n))$是肯定的啦。”</p></blockquote><h2 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h2><p>&emsp;&emsp;继续把第二步得到的式子代进第一步的式子里，就可以得到：</p><ul><li>Case 1:<br>$$<br>  T(n)=\theta(n^{log_ba})+O(n^{log_ba})=\theta(n^{log_ba})<br>$$</li><li>Case 2:<br>$$<br>  T(n)=\theta(n^{log_ba})+\theta(n^{log_ba}lgn)=\theta(n^{log_ba}lgn)<br>$$</li><li>Case 3:<br>$$<br>  T(n)=\theta(n^{log_ba})+\theta(f(n))=\theta(f(n))&emsp;,f(n)=\Omega(n^{log_ba+\epsilon})<br>$$</li></ul><p>&emsp;&emsp;上面的三个式子其实就是比较加号两边的式子的阶数，也可以看作是哪一个是主导因素。</p><blockquote><p>&emsp;&emsp;作者：“也可以看成是叶和枝谁是主导因素。”</p></blockquote><p>&emsp;&emsp;证毕。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;虽然是有局限性，主定理还是给了我们一种解递归方程的快速方法。<br><br>&emsp;&emsp;很多时候看到这种定理的时候都是有一种感觉：一直看下去好像每一步都懂，但是就是不知道他是怎么想出来的- -</p>]]></content>
      
      <categories>
          
          <category> Algorithm算法相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法导论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>系统降级后的0x000000A5错误</title>
      <link href="/2018/03/01/%E7%B3%BB%E7%BB%9F%E9%99%8D%E7%BA%A7%E5%90%8E%E7%9A%840x000000A5%E9%94%99%E8%AF%AF/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;Windows重装后蓝屏提示0x000000A5？<br><a id="more"></a></p><h1 id="症状"><a href="#症状" class="headerlink" title="症状"></a>症状</h1><p>&emsp;&emsp;机主的电脑本来是win8的，因为某种原因重装了个win7系统，在重装完成后的第一次重启（据说是激活的重启，但我觉得跟激活无关）后就出现蓝屏，提示0x000000A5，重启也无效。<br><figure class="image-box">                <img src="deemo1.JPG" alt="图是我网上找的- -，内容一样" title="" class="">                <p>图是我网上找的- -，内容一样</p>            </figure></p><h1 id="诊断"><a href="#诊断" class="headerlink" title="诊断"></a>诊断</h1><p>&emsp;&emsp;在我打算重装win7的时候，发现重装不了：<br><figure class="image-box">                <img src="deemo2.jpeg" alt="" title="" class="">                <p></p>            </figure><br>&emsp;&emsp;所以怀疑是电脑不兼容win7。</p><h1 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h1><p>&emsp;&emsp;安装win10的时候没有上面的问题，在重装到win10后就没有出现蓝屏了，问题解决。<br><br>&emsp;&emsp;另外，在蓝屏中也提到BIOS的问题，所以我觉得有可能是BIOS与win7不兼容，实在要装win7的话可以尝试把BIOS降一下级。（或者升一下级吧- -具体的我没试过）</p>]]></content>
      
      <categories>
          
          <category> Repairing修电脑相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 修电脑 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>限制EasyUI窗口的移动区域</title>
      <link href="/2018/02/10/%E9%99%90%E5%88%B6EasyUI%E7%AA%97%E5%8F%A3%E7%9A%84%E7%A7%BB%E5%8A%A8%E5%8C%BA%E5%9F%9F/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;前段时间使用EasyUI的Window插件时发现生成的窗口移动范围是整个页面，不能限制在一个区域，折腾了许久才找到解决方法。<br><a id="more"></a></p><h1 id="关于EasyUI的Window插件"><a href="#关于EasyUI的Window插件" class="headerlink" title="关于EasyUI的Window插件"></a>关于EasyUI的Window插件</h1><p>&emsp;&emsp;利用EasyUI的Window插件可以方便快速地、仅利用几行代码就可以生成一个窗口（没错，就是像Windows系统里面的窗口）。EasyUI还有很多插件，具体可以看看<a href="http://www.jeasyui.net/" target="_blank" rel="noopener">EasyUI中文网</a>。<br><br>&emsp;&emsp;EasyUI的入门与安装可以参考<a href="http://www.cnblogs.com/xdp-gacl/p/4075079.html" target="_blank" rel="noopener">这篇博客</a>，生成窗口的方法和演示可以参考<a href="http://www.jeasyui.net/demo/421.html" target="_blank" rel="noopener">这里</a>（这个是内联的，下面要用到）。<br><br>&emsp;&emsp;从上面的演示中，也可以看到，窗口是会移出父节点那个框框的，甚至有这种尴尬情况：<br><figure class="image-box">                <img src="deemo1.jpg" alt="" title="" class="">                <p></p>            </figure><br>&emsp;&emsp;在网上找解决办法时，找到的都是像<a href="http://www.bkjia.com/webzh/977413.html" target="_blank" rel="noopener">这样的</a>高度雷同的文章（我也不知道谁才是原文- -），但是里面的方法还是有不足的：拖拽只考虑了左方和上方；拉伸只考虑了右方和下方。于是我利用了他的方法做了一些改进：</p><h1 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h1><p>&emsp;&emsp;边上代码边说吧：<br><br>&emsp;&emsp;首先创建一个放窗口的区域,我把它取id为”area”，位置是绝对位置放在中间，为了可以看见这个区域，我加了边框和灰色背景色：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"area"</span> <span class="attr">style</span>=<span class="string">"position:absolute;width:600px;height:600px;left:200px;top:100px;border-style:solid;background-color:gray"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后把EasyUI中文网上的窗口（内联，其实就是加个”inline:true”）代码放进去：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin:20px 0;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span> <span class="attr">class</span>=<span class="string">"easyui-linkbutton"</span> <span class="attr">onclick</span>=<span class="string">"$('#w').window('open')"</span>&gt;</span>Open<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span> <span class="attr">class</span>=<span class="string">"easyui-linkbutton"</span> <span class="attr">onclick</span>=<span class="string">"$('#w').window('close')"</span>&gt;</span>Close<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"area"</span> <span class="attr">style</span>=<span class="string">"position:absolute;width:600px;height:600px;left:200px;top:100px;border-style:solid;background-color:gray"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"w"</span> <span class="attr">class</span>=<span class="string">"easyui-window"</span> <span class="attr">title</span>=<span class="string">"Basic Window"</span> <span class="attr">data-options</span>=<span class="string">"iconCls:'icon-save',inline:true"</span> <span class="attr">style</span>=<span class="string">"width:500px;height:200px;padding:10px;"</span>&gt;</span></span><br><span class="line">The window content.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样生成的窗口和网站上的演示一样，不能限制在那个区域内。于是下面是script：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//页面（包括图像）已经完全呈现时，会发生 ready 事件</span></span><br><span class="line">    <span class="keyword">var</span> moving = <span class="literal">false</span>;  <span class="comment">//用来标志用户是否在拖动窗口，原因是onResize与onMove会互作</span></span><br><span class="line">    </span><br><span class="line">    $(<span class="string">"#w"</span>).window(&#123;</span><br><span class="line">    <span class="comment">//拖动时</span></span><br><span class="line">        onMove:<span class="function"><span class="keyword">function</span>(<span class="params">left,top</span>)</span>&#123; <span class="comment">//onMove事件，用户拖动时触发</span></span><br><span class="line">            moving = <span class="literal">true</span>; <span class="comment">//标志正在拖动</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">var</span> w=$(<span class="string">"#area"</span>).width(); <span class="comment">//限制区域的宽度</span></span><br><span class="line">            <span class="keyword">var</span> h=$(<span class="string">"#area"</span>).height(); <span class="comment">//限制区域的高度</span></span><br><span class="line">            <span class="keyword">var</span> width=$(<span class="string">"#w"</span>).window(<span class="string">"options"</span>).width; <span class="comment">//窗口宽度</span></span><br><span class="line">            <span class="keyword">var</span> height=$(<span class="string">"#w"</span>).window(<span class="string">"options"</span>).height; <span class="comment">//窗口高度</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">//如果窗口上端超出限制区域上端（因为是内联，所以是0）</span></span><br><span class="line">            <span class="keyword">if</span>(top&lt;<span class="number">0</span>)&#123; </span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">top</span>:<span class="number">0</span>&#125;); </span><br><span class="line">                <span class="comment">//把窗口上端限制在区域上端</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果窗口下端超出限制区域下端（height+top就是bottom了）</span></span><br><span class="line">            <span class="keyword">if</span>((height+top)&gt;h)&#123; </span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">top</span>:h-height&#125;); </span><br><span class="line">                <span class="comment">//把窗口下端限制在区域下端</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果窗口左端超出限制区域左端（因为是内联，所以是0）</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;<span class="number">0</span>)&#123; </span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">left</span>:<span class="number">0</span>&#125;); </span><br><span class="line">                <span class="comment">//把窗口左端限制在区域左端</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果窗口右端超出限制区域右端（width+left就是right了）</span></span><br><span class="line">            <span class="keyword">if</span>((width+left)&gt;w)&#123; </span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">left</span>:w-width&#125;); </span><br><span class="line">                <span class="comment">//把窗口右端限制在区域右端</span></span><br><span class="line">            &#125;</span><br><span class="line">            moving = <span class="literal">false</span>; <span class="comment">//完成，标志为没有在拖动</span></span><br><span class="line">        &#125;,</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//拉伸时</span></span><br><span class="line">        onResize:<span class="function"><span class="keyword">function</span>(<span class="params">width, height</span>)</span>&#123; <span class="comment">//onResize事件</span></span><br><span class="line">            <span class="keyword">if</span>(moving)&#123;<span class="keyword">return</span>;&#125;  </span><br><span class="line">            <span class="comment">//有时候拖动时会触发onResize（比如拖到左上角，左边和上边同时越界时）</span></span><br><span class="line">            <span class="comment">//所以如果在拖动的话直接跳过onResize</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">var</span> w=$(<span class="string">"#area"</span>).width(); <span class="comment">//限制区域的宽度</span></span><br><span class="line">            <span class="keyword">var</span> h=$(<span class="string">"#area"</span>).height(); <span class="comment">//限制区域的高度</span></span><br><span class="line">            <span class="keyword">var</span> left=$(<span class="string">"#w"</span>).window(<span class="string">"options"</span>).left; <span class="comment">//窗口左端</span></span><br><span class="line">            <span class="keyword">var</span> top=$(<span class="string">"#w"</span>).window(<span class="string">"options"</span>).top; <span class="comment">//窗口顶端</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(top&lt;<span class="number">0</span>)&#123; <span class="comment">//如果窗口上端超出限制区域上端（因为是内联，所以是0）</span></span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">height</span>:height+top,<span class="attr">top</span>:<span class="number">0</span>&#125;); </span><br><span class="line">                <span class="comment">//把窗口上端限制在区域上端，同时保持高度不变（这时top是负值，且绝对值为超出的长度）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果窗口下端超出限制区域下端</span></span><br><span class="line">            <span class="keyword">if</span>((height+top)&gt;h)&#123;</span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">height</span>:h-top&#125;);</span><br><span class="line">                <span class="comment">//因为拉伸下面时top没改变，所以直接保持高度不变就行了（height的计算就是if表达式里面的变形）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果窗口左端超出限制区域左端</span></span><br><span class="line">            <span class="keyword">if</span>(left&lt;<span class="number">0</span>)&#123;</span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">width</span>:width+left,<span class="attr">left</span>:<span class="number">0</span>&#125;);</span><br><span class="line">                <span class="comment">//把窗口左端限制在区域左端，同时保持宽度不变（这时left是负值，且绝对值为超出的长度）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果窗口右端超出限制区域右端</span></span><br><span class="line">            <span class="keyword">if</span>((width+left)&gt;w)&#123;</span><br><span class="line">                $(<span class="string">"#w"</span>).window(<span class="string">"resize"</span>,&#123;<span class="attr">width</span>:w-left&#125;);</span><br><span class="line">                <span class="comment">//因为拉伸右面时left没改变，所以直接保持宽度不变就行了</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;一不小心就把代码打全了，注释虽然有点密密麻麻，但应该看得懂的。<br><br><br><br>&emsp;&emsp;最后发一个演示：<a href="http://jsfiddle.net/kwV9G/423/" target="_blank" rel="noopener">☞戳我☜</a></p>]]></content>
      
      <categories>
          
          <category> Web网络相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用旧安卓机打造伪家用Linux服务器</title>
      <link href="/2018/02/04/%E5%88%A9%E7%94%A8%E6%97%A7%E5%AE%89%E5%8D%93%E6%9C%BA%E6%89%93%E9%80%A0%E4%BC%AA%E5%AE%B6%E7%94%A8Linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;“知道有Termux后，我的红米1S复活了！”<br><a id="more"></a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&emsp;&emsp;Termux是一个安卓的终端模拟器，它与很多其他的终端模拟器的不同在于它多了很多命令，而我觉得最特别的是它居然内置了包管理工具apt和pkg，据说Termux自己维护了一个源，提供各种专门为termux定制的包。<br>&emsp;&emsp;还有一点，Termux是免root的，所以在“apt install …”时也不用加“sudo”<br>&emsp;&emsp;总而言之，Termux非常强大，于是我就打算利用它把我的旧红米1S打造成一个家用服务器。（好，这里广告打完了，顺便推荐一篇<a href="http://tonybai.com/2017/11/09/hello-termux/" target="_blank" rel="noopener">写Termux写得挺好的博文</a>）</p><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="①安卓手机一台"><a href="#①安卓手机一台" class="headerlink" title="①安卓手机一台"></a>①安卓手机一台</h2><p>&emsp;&emsp;据我所知Termux是只有安卓版本的，跟用苹果的朋友无缘了，在<a href="https://termux.com/" target="_blank" rel="noopener">官网</a>中也说明了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Termux is an Android terminal emulator and Linux environment app that works directly with no rooting or setup required.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;对于安卓的手机也是有条件限制的——安卓的版本必须是5.0以上，不然会安装不了。这个在<a href="https://wiki.termux.com/wiki/FAQ" target="_blank" rel="noopener">官方的Wiki</a>中也有说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Termux is only available on Android 5.0 or later. See https://github.com/termux/termux-app/issues/6 for more information.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如果手里的安卓机版本太低，可以考虑刷一下机（当然如果你舍得刷的话。。），像我的红米1S万年安卓4.4，为了装Termux最后还是刷了个<a href="https://zh.wikipedia.org/wiki/CyanogenMod#CyanogenMod_13" target="_blank" rel="noopener">CM13</a>(安卓6.0)。</p><h2 id="②Termux软件一个"><a href="#②Termux软件一个" class="headerlink" title="②Termux软件一个"></a>②Termux软件一个</h2><p>&emsp;&emsp;这个在<a href="https://termux.com/" target="_blank" rel="noopener">官网</a>下载安装就可以了，懂得”climb over the wall”的可以直接在Google Play下载，在F-Droid也可以，另外国内的应用商店里好像也有。</p><h2 id="③Root-可选"><a href="#③Root-可选" class="headerlink" title="③Root(可选)"></a>③Root(可选)</h2><p>&emsp;&emsp;只是使用Termux的话是不用root的，但是想要用得更爽的话，有root会方便很多。如果不想root的可以跳过。<br><br>&emsp;&emsp;Root的方法网上有很多，MIUI的话可以刷开发版，CyanogenMod的话好象是自带的，实在不行下个刷机精灵之类的软件线刷就好。</p><h2 id="④Busybox-可选-须Root"><a href="#④Busybox-可选-须Root" class="headerlink" title="④Busybox(可选)(须Root)"></a>④Busybox(可选)(须Root)</h2><p>&emsp;&emsp;据说有了<a href="https://zh.wikipedia.org/wiki/BusyBox" target="_blank" rel="noopener">Busybox</a>会使命令更全，虽然我觉得Termux的命令也是挺全的，但装了也没有坏处。这个可选，但安装的话需要root权限。<br><figure class="image-box">                <img src="deemo2.jpg" alt="busybox的介绍和它的命令" title="" class="">                <p>busybox的介绍和它的命令</p>            </figure></p><h2 id="⑤一个适合打代码的键盘"><a href="#⑤一个适合打代码的键盘" class="headerlink" title="⑤一个适合打代码的键盘"></a>⑤一个适合打代码的键盘</h2><p>&emsp;&emsp;想象一下你在用Vim的时候没有Esc键的感觉。。<br><br>&emsp;&emsp;这里我推荐CodeBoard(<a href="https://play.google.com/store/apps/details?id=com.gazlaws.codeboard" target="_blank" rel="noopener">Google Play</a> , <a href="http://www.wandoujia.com/apps/com.gazlaws.codeboard" target="_blank" rel="noopener">豌豆荚</a>)，如果舍得的话买一个蓝牙键盘也是不错的选择。</p><h1 id="探索：更多玩法"><a href="#探索：更多玩法" class="headerlink" title="探索：更多玩法"></a>探索：更多玩法</h1><p>&emsp;&emsp;到这里，服务器就搭好了（你没看错！），但是一个空的服务器没什么用，接下来就要在里面安装各种应用。</p><h2 id="①访问手机储存"><a href="#①访问手机储存" class="headerlink" title="①访问手机储存"></a>①访问手机储存</h2><p>&emsp;&emsp;Termux里的文件是放在应用的内部存储里的，看一下它的home目录，比如输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="variable">$HOME</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;会得到：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/data/data/com.termux/files/home</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样的话要访问手机里的文件就有点困难，下面介绍三种方法访问手机的文件：<br><br>⑴  按照官方的方法的话，是先在手机的应用权限里授予手机储存访问权限，然后输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">termux-setup-storage</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样在home目录里面就会多了个storage目录，里面的文件就是手机储存里面的相应文件:<br><figure class="image-box">                <img src="deemo1.jpg" alt="在storage目录下还有这几个目录" title="" class="">                <p>在storage目录下还有这几个目录</p>            </figure><br>&emsp;&emsp;参考一下官方的说法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">To grant storage permissions in Android goto Settings&gt;Apps&gt;Termux&gt;Permissions and select storage, then run termux-setup-storage in Termux.</span><br></pre></td></tr></table></figure></p><p>⑵ 直接访问：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /storage/emulated/0</span><br><span class="line">ls</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;因为这个文件夹是可读写的（在设置中授予读写权限后），所以可以直接访问，如果是外置的储存卡的话要知道外置储存卡的路径才能用这种方法。<br>⑶ 创建符号链接，跟方法二类似：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -s /storage/emulated/0 ~/storage(←这个名字和路径是自己取的)</span><br></pre></td></tr></table></figure></p><h2 id="②OpenSSH"><a href="#②OpenSSH" class="headerlink" title="②OpenSSH"></a>②OpenSSH</h2><p>&emsp;&emsp;首先要远程链接的话要用到<a href="https://zh.wikipedia.org/wiki/Secure_Shell" target="_blank" rel="noopener">ssh(Secure Shell)</a>,刚安装好的Termux是不能用ssh的，输入“ssh”的话会提示：<br><figure class="image-box">                <img src="deemo002.jpg" alt="" title="" class="">                <p></p>            </figure><br>&emsp;&emsp;根据提示敲”pkg install openssh”或者”apt install openssh”安装OpenSSH。<br><br>&emsp;&emsp;如果要链接远程设备的话可以输入（前提是对方开了ssh服务）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#链接：</span></span><br><span class="line">ssh 用户名@IP地址 -p 端口号</span><br><span class="line"><span class="comment">#下载：</span></span><br><span class="line">scp -P 端口号 用户名@IP地址 本地路径</span><br><span class="line"><span class="comment">#上传：</span></span><br><span class="line">scp -P 端口号 本地路径 用户名@IP地址</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;端口号默认是22,是默认的话可以不输入（记得-p也不要打）。看不懂我写的可以参考一下<a href="https://www.jianshu.com/p/b70089f4c187" target="_blank" rel="noopener">这里</a>。<br><br>&emsp;&emsp;如果要开启服务器（我说的是那个安卓手机）的ssh服务的话可以使用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sshd -p 端口号</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;不加端口号（”-p”也是）的话是默认端口号8022（如果是Linux的话默认是22，据说安卓为了保护端口开1024以下的端口）。<br><br>&emsp;&emsp;其他设备要连接服务器时要知道服务器的IP，可以用命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后找到最像IP地址的那个（通常连接路由器的话是192.168.*.*），另外，如果没有公网IP的话（家用的估计也是没有的了。。）两个设备要连接同一个内网（Wifi）。<br><figure class="image-box">                <img src="deemo4.jpg" alt="最像IP的IP" title="" class="">                <p>最像IP的IP</p>            </figure><br>&emsp;&emsp;上面的搞定之后还是不能直接连上的，因为Termux不支持使用密码登陆，所以只能使用免密码登陆，<a href="https://termux.com/ssh.html" target="_blank" rel="noopener">官方</a>原话：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Termux sshd binary does not support password logins, so a key needs to be authorized in ~/.ssh/authorized_keys before connecting. Use ssh-keygen to generate a new one if desired.</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;首先要在自己的设备（不是指那个安卓手机）上生成私钥（已经有的可以跳过，就是在 ~/.ssh 里有 id_rsa.pub 这个文件）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在生成的时候可能会让你输一个密码（好像是“Enter passphrase (empty for no passphrase)”）不需要的可以直接回车，如果输入了的话要记住，以后每次登陆都会用到。<br><br>&emsp;&emsp;然后找到 ~/.ssh 里的 id_rsa.pub 这个文件想方设法把里面的内容复制到服务器（安卓手机）的 ~/.ssh 目录下的 authorized_keys 文件里面。方法有很多，可以直接复制粘贴，也可以两个文件放在同一目录后执行(重定向输出)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat id_rsa.pub &gt;&gt; authorized_keys</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如无意外的话到这里就配置成功了，ssh免密码登陆看不懂的话可以参考<a href="https://www.jianshu.com/p/e9db116fef8c" target="_blank" rel="noopener">这里</a>。</p><h2 id="③Vim"><a href="#③Vim" class="headerlink" title="③Vim"></a>③Vim</h2><p>&emsp;&emsp;<a href="http://www.vim.org/" target="_blank" rel="noopener">Vim</a>是Linux上一个功能强大的文本编辑器（有多强大？用一下就知道咯。），用以下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install vim</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;顺便推荐一个<a href="https://github.com/ma6174/vim-deprecated" target="_blank" rel="noopener">可以一键安装的vim插件</a>（这个比较旧了，都没有维护了），里面的自动安装在安卓机上是不适用的，但是可以在电脑上装好后再覆盖home目录下的 .vim 文件夹和 .vimrc 文件，这两个文件是隐藏的，可以通以下命令查看：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;Vim的教程<a href="http://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">网上</a>很多，嫌网上找麻烦的可以在vim里输入：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:<span class="built_in">help</span></span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="deemo5.jpg" alt="help文档，不过是英文的" title="" class="">                <p>help文档，不过是英文的</p>            </figure><p>&emsp;&emsp;查看官方的教程（没改过的话是英文的），如果实在嫌vim用起来麻烦的话可以用nano：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install nano</span><br></pre></td></tr></table></figure></p><h2 id="④GCC"><a href="#④GCC" class="headerlink" title="④GCC"></a>④GCC</h2><p>&emsp;&emsp;如果是还在用C或C++的话应该对它非常熟悉，简单地说，<a href="https://zh.wikipedia.org/wiki/GCC" target="_blank" rel="noopener">GCC</a>就是个编译器，在Termux中，输入gcc的话它会提示你安装Clang，简单地说，<a href="https://zh.wikipedia.org/wiki/Clang" target="_blank" rel="noopener">Clang</a>也是一个编译器。<br><figure class="image-box">                <img src="deemo001.jpg" alt="" title="" class="">                <p></p>            </figure><br>&emsp;&emsp;执行以下命令安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install clang</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;安装Clang后同样可以使用gcc或者是g++命令编译C或者C++文件。</p><h2 id="⑤make"><a href="#⑤make" class="headerlink" title="⑤make"></a>⑤make</h2><p>&emsp;&emsp;有了<a href="https://zh.wikipedia.org/wiki/Make" target="_blank" rel="noopener">make</a>，就可以<a href="https://www.linuxidc.com/Linux/2015-04/115812.htm" target="_blank" rel="noopener">从源码安装Linux软件</a>了，同样用pkg安装：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install make</span><br></pre></td></tr></table></figure></p><h2 id="⑥git"><a href="#⑥git" class="headerlink" title="⑥git"></a>⑥git</h2><p>&emsp;&emsp;<a href="https://git-scm.com/" target="_blank" rel="noopener">git</a>这个东西我只是用过在<a href="https://github.com/" target="_blank" rel="noopener">Github</a>上下载和上传文件，所以我会的也不多- -。安装git:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install git</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;用来下载的话是命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> 地址 本地路径(省略的话就是当前路径)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;创建仓库的话可以参考<a href="https://lellansin.wordpress.com/2013/02/21/git-%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C-%E4%B8%80/" target="_blank" rel="noopener">这个</a>。</p><h2 id="⑦Scheme"><a href="#⑦Scheme" class="headerlink" title="⑦Scheme"></a>⑦Scheme</h2><p>&emsp;&emsp;如果有看<a href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A" target="_blank" rel="noopener">SICP</a>的话，肯定会忍不住装一个Scheme（像我- -），在Termux里装的是 tinyscheme ，同样用pkg：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install tinyscheme</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;运行的话是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接运行：</span></span><br><span class="line">tinyscheme</span><br><span class="line"><span class="comment">#运行文件：</span></span><br><span class="line">tinyscheme 文件</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;有一个不太方便的就是tinyscheme不支持方向键，如果打了一大串发现前面少了个括号的话。。。解决方法我是参考<a href="http://deathking.github.io/2015/08/07/armored-your-mit-scheme/" target="_blank" rel="noopener">这篇文章</a>。首先安装rlwrap：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install rlwrap</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后按照那篇文章的，生成 .scheme_completion.txt 文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line">touch .scheme_completion.txt</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;把那个<a href="https://gist.github.com/bobbyno/3325982" target="_blank" rel="noopener">gist</a>里面的东西复制进去（或者直接 git clone 那个文件也行）。<br><br>&emsp;&emsp;运行时用以下命令(注意这里是tinyscheme，因为我们没有scheme这个命令)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlwrap -r -c -f <span class="string">"<span class="variable">$HOME</span>"</span>/.scheme_completion.txt tinyscheme</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这样的话就可以用方向键了（还有那篇文章里的SLIB我还没装成功，你们谁装好的教我一下啊~），但是每次运行都输入这么一大串命令的话也是挺麻烦的，为了方便，我先把他写成一个脚本。另外，为了可以输入 scheme 就可以运行，我把它放进bin目录里。<br><br>&emsp;&emsp;首先Termux的bin目录是在home目录上层的usr目录里面：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/../usr/bin</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后创建一个叫 scheme 的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch scheme</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;给予<a href="https://zhidao.baidu.com/question/9603503" target="_blank" rel="noopener">777权限</a>：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 ./scheme</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后把脚本复制进去：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> rlwrap -n -r -c -f  <span class="string">"<span class="variable">$HOME</span>"</span>/.scheme_completion.txt tinyscheme <span class="variable">$@</span> &gt; ./scheme</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;或者用vim打开把这个复制进去也行(注意是tinyscheme！不然就是一个递归的死循环了！)：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rlwrap -n -r -c -f  <span class="string">"<span class="variable">$HOME</span>"</span>/.scheme_completion.txt tinyscheme <span class="variable">$@</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后就可以直接用 scheme 命令运行了：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#直接运行：</span></span><br><span class="line">scheme</span><br><span class="line"><span class="comment">#运行文件：</span></span><br><span class="line">scheme 文件</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="deemo6.jpg" alt="" title="" class="">                <p></p>            </figure><h2 id="⑧Node-js"><a href="#⑧Node-js" class="headerlink" title="⑧Node.js"></a>⑧Node.js</h2><p>&emsp;&emsp;如果想用服务器（那个安卓手机）来运行网站的话，可以用<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">Node.js</a>（当然可以用其他，只是我只会这个- -），安装的话可以：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install nodejs</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;查看是否安装成功的话可以：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="deemo7.jpg" alt="" title="" class="">                <p></p>            </figure><p>&emsp;&emsp;另外npm应该也是一起安装的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="deemo8.jpg" alt="" title="" class="">                <p></p>            </figure><p>&emsp;&emsp;运行的话是用命令 node ，但有些时候好像是要用命令 nodejs 的（忘了是什么时候了），所以保险一点把这个命令复制一份：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp ~/../usr/bin/node ~/../usr/bin/nodejs</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;到这里Node.js就安装完了，如果要试着玩一下的话可以先装个<a href="https://github.com/expressjs/express" target="_blank" rel="noopener">Express</a>:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g express-generator</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后到你想要的目录里运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express web(←这个名字是自己取的)</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后就创建了一个 web 目录，进去这个目录里，然后执行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> web</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;把做好的网页改名为 index.html （不改也行，改了方便一点），放到 web/public/ 里面，然后运行：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="deemo9.jpg" alt="" title="" class="">                <p></p>            </figure><p>&emsp;&emsp;然后就会提示网站在端口 3000 运行（没改过的话是3000）,要改端口的话是在 web/bin/www 文件里。用 ifconfig 得到IP后，在内网输入 IP:端口 就可以了。<br><br>&emsp;&emsp;Node.js要讲的话东西还有很多，这里只是介绍一下。</p><h2 id="⑨个性化bash"><a href="#⑨个性化bash" class="headerlink" title="⑨个性化bash"></a>⑨个性化bash</h2><p>&emsp;&emsp;刚安装Termux时，bash的提示符就只有一个”$”，怎么看这个也太简单了，如果知道如何<a href="http://www.cnblogs.com/killkill/archive/2010/06/01/1749012.html" target="_blank" rel="noopener">定制个性化的bash</a>的话，肯定不会满足这样的提示符。下面介绍一下个性化Termux的bash的方法：<br><figure class="image-box">                <img src="deemo003.jpg" alt="" title="" class="">                <p></p>            </figure><br>&emsp;&emsp;一个方法是<a href="http://www.cnblogs.com/killkill/archive/2010/06/01/1749012.html" target="_blank" rel="noopener">上面那篇文章</a>说的：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PS1=<span class="string">"这里填你想要的提示符"</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里的原理其实就是修改<a href="http://blog.51cto.com/xiaozhuang/844781" target="_blank" rel="noopener">环境变量PS1</a>，PS1就是主提示符变量。但是我用这个方法的时候，在重启Termux后提示符就会恢复为”$”，所以就有了方法二（修改<a href="https://zhidao.baidu.com/question/129164766.html" target="_blank" rel="noopener">bashrc</a>）：<br><br>&emsp;&emsp;在Termux中，bashrc是在 /data/data/com.termux/files/usr/etc/<br>或者 ~/…/usr/etc/ 里面，叫做 bash.bashrc 。要修改提示符变量的话只须在 bash.bashrc 里面添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">'这里填你想要的提示符'</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;修改完以后要重启一下bash。比如说我的提示符就是：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PS1=<span class="string">'\[\033[01;31m\]☂  \[\033[02;00m\]\t\[\033[01;34m\] \w\n\[\033[01;32m\]\u@Android\[\033[00m\] \[\033[02;00m\]\$'</span></span><br></pre></td></tr></table></figure></p><figure class="image-box">                <img src="deemo10.jpg" alt="" title="" class="">                <p></p>            </figure><p>&emsp;&emsp;另外，如果是用vim修改显示不了unicode字符的话，可以在 ~/.vimrc 里面添加：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> encoding=utf-8</span><br></pre></td></tr></table></figure></p><h2 id="⑩sudo-须root"><a href="#⑩sudo-须root" class="headerlink" title="⑩sudo(须root)"></a>⑩sudo(须root)</h2><p>&emsp;&emsp;在真正的Linux系统中，要切换为超级用户只需要输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在Termux中使用 su 的话，虽然可以切换为超级用户，但是有很多Termux的命令都用不了（像普通的终端模拟器一样），这样在用需要root的操作时就极不方便。<br><br>&emsp;&emsp;对此，Termux提供的方法是使用tsu：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install tsu</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;另一种获得权限的方法是 <a href="https://zh.wikipedia.org/wiki/Sudo" target="_blank" rel="noopener">sudo</a> ，这种方法的优点是不用切换为超级用户就可以获得权限。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo 需要权限才能执行的命令</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在Termux是没有sudo命令的，但是可以自己添加（前提是可以使用su）。具体参考<a href="https://github.com/st42/termux-sudo" target="_blank" rel="noopener">st42的github</a>。<br><br>&emsp;&emsp;首先安装 ncurses-utils ：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pkg install ncurses-utils</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;下载<a href="https://github.com/st42/termux-sudo" target="_blank" rel="noopener">github</a>上的文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/st42/termux-sudo.git</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;进入目录后，执行以下命令把 sudo 放到 bin 目录下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat sudo &gt; /data/data/com.termux/files/usr/bin/sudo</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后给予 sudo 读写权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 700 /data/data/com.termux/files/usr/bin/sudo</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;到这里sudo就安装好了。su、tsu和sudo在Termux中各有自己的优点和缺点。我推荐的话是三个对比着用，哪个适当的话就用哪个。<br><figure class="image-box">                <img src="deemo12.jpg" alt="sudo的用法" title="" class="">                <p>sudo的用法</p>            </figure><br><figure class="image-box">                <img src="deemo13.jpg" alt="tsu，退出时输入exit" title="" class="">                <p>tsu，退出时输入exit</p>            </figure><br><figure class="image-box">                <img src="deemo14.jpg" alt="su，可以看到bash的提示符都变了" title="" class="">                <p>su，可以看到bash的提示符都变了</p>            </figure></p><h2 id="⑪其他"><a href="#⑪其他" class="headerlink" title="⑪其他"></a>⑪其他</h2><p>&emsp;&emsp;还没想到，我想到再写吧~</p><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>&emsp;&emsp;可能是因为安卓手机休眠后会关闭后台进程（省电），有时熄屏后会出现ssh连不上或者nodejs的网页打不开的情况，有时还会vim等了很久都还没打开，最终要按亮屏幕才能打开。这样每次都要按亮屏幕的话就会很不方便，所以就有了以下这个还算好的解决办法（须root）：<br><br>&emsp;&emsp;首先让手机不休眠，这个的话通常在手机的设置里就有（如果没有不休眠的这个选项的话就选时间最长的那个，比如我的CyanogenMod最长只能选 无操作30分钟后休眠 ）。<br><br>&emsp;&emsp;因为手机耗电的主要是屏幕，接下来把屏幕亮度调到最低。调节安卓手机屏幕亮度的话可以修改<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sys/class/leds/lcd-backlight/brightness</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个文件，这个文件里面写的是一个范围在0到一个储存在同目录下叫 max_brightness 的文件里的数字，我们要最暗的话只须写入0。首先要给这个文件读写权限：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 666 /sys/class/leds/lcd-backlight/brightness</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;然后写入0:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> 0 &gt; /sys/class/leds/lcd-backlight/brightness</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;如无意外的话会看见手机像熄屏了一样，但是这只是设置成没有亮度，其他的还是跟亮屏时一样。<br><br>&emsp;&emsp;注意这样的话会比平时更耗电，请考虑过后才操作。<br><br>&emsp;&emsp;最后把它写脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#比如说我的文件名叫做 brightness.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#检测有没有读写权限，没有的话就给予读写权限</span></span><br><span class="line">    <span class="keyword">if</span> [ ! -w /sys/class/leds/lcd-backlight/brightness -o ! -r  /sys/class/leds/lcd-backlight/brightness ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line">sudo chmod 666 /sys/class/leds/lcd-backlight/brightness </span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#判断是否在范围内</span></span><br><span class="line">    <span class="keyword">if</span> [ <span class="variable">$1</span> -ge 0 -o <span class="variable">$1</span> -le 255 ]</span><br><span class="line">    <span class="keyword">then</span></span><br><span class="line"><span class="comment">#把亮度写进brightness文件</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$1</span> &gt; /sys/class/leds/lcd-backlight/brightness </span><br><span class="line"><span class="built_in">echo</span> Setted brightness to <span class="variable">$1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> Error!</span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="comment">#最后看看亮度有没有改变</span></span><br><span class="line">    <span class="built_in">echo</span> Now brightness is:</span><br><span class="line">    cat /sys/class/leds/lcd-backlight/brightness</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;使用的时候是（在文件所在路径）：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh ./brightness 一个亮度的数字(比如0)</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;一番折腾后，手机已经比较像个服务器了，为什么一部安卓手机可以弄成一个像Linux的服务器？因为安卓的内核就是Linux！参考<a href="http://www.techug.com/post/linux-and-android.html" target="_blank" rel="noopener">☛这个</a>。<br>&emsp;&emsp;</p>]]></content>
      
      <categories>
          
          <category> Android安卓相关 </category>
          
          <category> Linux系统相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c++矩阵类-初阶[0]</title>
      <link href="/2018/01/31/c-%E7%9F%A9%E9%98%B5%E7%B1%BB-%E5%88%9D%E9%98%B6-0/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;构造函数怎么写好?<br><a id="more"></a></p><hr><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><hr><p>&emsp;&emsp;首先应该用什么来存放一个矩阵？比较容易的会想到用二维数组，为此需要一个指针指向这个二位数组，我把它叫做“matrix_p”。另外，矩阵中的数应该是实数，为了偷懒用double类型就好了。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> **matrix_p;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;在构造矩阵的时候还要明确矩阵的大小，即行数和列数，这里我把它们分别叫做“m_row”和“m_col”。类型为int即可。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> m_row;</span><br><span class="line"><span class="keyword">int</span> m_col;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;另外为了方便遇到错误时可以发出警告且退出程序，我还写了一个函数（先在这里放出来，有一些还没用到的）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(<span class="keyword">int</span> mark)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(mark)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Row or column should be more than zero!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Format error!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Inner bracket error!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Outer bracket error!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Size not match!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Warning: row not exit!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Not invertable!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:<span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"Not projectable!"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="构造函数："><a href="#构造函数：" class="headerlink" title="构造函数："></a>构造函数：</h1><hr><h2 id="需求①：构造一个空的矩阵"><a href="#需求①：构造一个空的矩阵" class="headerlink" title="需求①：构造一个空的矩阵"></a>需求①：构造一个空的矩阵</h2><p>&emsp;&emsp;这个比较简单，只要把行数和列数定为0,指针指向空就好了。直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">Matrix::Matrix()  <span class="comment">//Matrix是我的类名</span></span><br><span class="line">&#123;</span><br><span class="line">    m_row = <span class="number">0</span>;</span><br><span class="line">    m_col = <span class="number">0</span>;</span><br><span class="line">    matrix_p = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">## 需求②：构造一个指定行数和列数的零矩阵</span><br><span class="line">&amp;emsp;&amp;emsp;这里行数和列数比较好处理，直接在参数中传进去就好了，关键是怎么构建出一个二维数组，先看看代码：</span><br><span class="line">```c++</span><br><span class="line">Matrix::Matrix(<span class="keyword">int</span> row,<span class="keyword">int</span> col)  <span class="comment">//参数有两个，分别为行数和列数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;<span class="number">0</span> &amp;&amp; col &gt;<span class="number">0</span>)  <span class="comment">//检验一下输传入的行数和列数是否合理（大于0）</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_row = row;    <span class="comment">//给行数赋值</span></span><br><span class="line">        m_col = col;    <span class="comment">//给列数赋值</span></span><br><span class="line">      <span class="comment">/*下面几步开始处理矩阵（二位数组），相当于“double matrix_p[m_row][m_col] = &#123;0&#125;”*/</span></span><br><span class="line">        matrix_p = <span class="keyword">new</span> <span class="keyword">double</span>*[m_row];  <span class="comment">//首先指针指向一个一维数组（数组里面元素为指针）</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;m_row;r++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix_p[r] = <span class="keyword">new</span> <span class="keyword">double</span>[m_col];  <span class="comment">//然后一维数组中每一个元素（指针）再指向一个一维数组</span></span><br><span class="line">  <span class="comment">/*这样就申请了一个动态二位数组*/</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;m_col;c++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix_p[r][c] = <span class="number">0</span>;   <span class="comment">//最后对矩阵每一个元素赋0值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="number">1</span>);  <span class="comment">//自己写的函数：这里当行数和列数不合理时发送一个错误，并且退出程序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这里通过动态生成的二位数组与正常创建的二维数组（如：double matrix_p[m_row][m_col]）不同，严格来说这样的二位数组的内存空间是不连续的（随便翻了个<a href="https://zhidao.baidu.com/question/160680492.html" target="_blank" rel="noopener">百度知道</a>）。</p><h2 id="需求③：不仅指定行数和列数，还通过数组（一维）确定矩阵元素的值"><a href="#需求③：不仅指定行数和列数，还通过数组（一维）确定矩阵元素的值" class="headerlink" title="需求③：不仅指定行数和列数，还通过数组（一维）确定矩阵元素的值"></a>需求③：不仅指定行数和列数，还通过数组（一维）确定矩阵元素的值</h2><p>&emsp;&emsp;要传递矩阵元素的值给构造函数，可以把它们放在一个容器（数组，vector等）里面传递，这里为了简单选用了一维数组。<br><br><br>&emsp;&emsp;对比需求②，这里只有两处不同：一是参数从两个变成三个；而是赋值不是赋0值，而是赋数组里面的值。看代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Matrix::Matrix(<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">double</span> *input_matrix)</span><br><span class="line"><span class="comment">//参数多了一个double类型的一维数组</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(row&gt;<span class="number">0</span> &amp;&amp; col &gt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_row = row;</span><br><span class="line">        m_col = col;</span><br><span class="line">        matrix_p = <span class="keyword">new</span> <span class="keyword">double</span>*[m_row];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;m_row;r++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix_p[r] = <span class="keyword">new</span> <span class="keyword">double</span>[m_col];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;m_col;c++)</span><br><span class="line">            &#123;</span><br><span class="line">                matrix_p[r][c] = input_matrix[r*m_col+c];</span><br><span class="line">                <span class="comment">//把数组的值赋给矩阵，表达式r*m_col+c把矩阵中元素的位置与一维数组中的元素位置对应起来。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        error(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;看着很合理，但是却存在一个漏洞：如果 传入的数组的长度小于矩阵的行数与列数的积 的话，就会发生数组越界（<a href="http://phonzia.github.io/2016/07/C++%E4%B8%AD%E7%9A%84%E6%AE%B5%E9%94%99%E8%AF%AF-%E4%B8%80-%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C" target="_blank" rel="noopener">一篇别人的文章</a>），因为 r*m_col+c 已经大于数组长度了。我猜用vector的话应该可以避免这个问题吧（没试过）。接下来介绍另一种方式：</p><h2 id="需求④：通过字符串确定矩阵元素的值"><a href="#需求④：通过字符串确定矩阵元素的值" class="headerlink" title="需求④：通过字符串确定矩阵元素的值"></a>需求④：通过字符串确定矩阵元素的值</h2><p>&emsp;&emsp;这里我参考了<a href="http://reference.wolfram.com/language/ref/MatrixForm.html" target="_blank" rel="noopener">Wolfram输入矩阵的格式</a>,（“$ \{ \{ ∗,…,∗\},…,\{∗,…,∗\}\} $”，其实就是我们初始化二维数组时的格式嘛）。<br>&emsp;&emsp;这样传递的话，其实就是要在函数里一个个地读字符串里面的字符，读取到相应的数字就把它放到矩阵中，读取到其他标记符（大括号与逗号）就作出相应的处理，所以这个函数里面应该是有一大堆判断（if）的。<br>&emsp;&emsp;看一下代码（这个比较长，要分几段）：<br>&emsp;&emsp;首先是一大堆中间变量：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//"&#123;&#123;*,...,*&#125;,...,&#123;*,...,*&#125;&#125;"  //格式</span></span><br><span class="line">Matrix::Matrix(<span class="built_in">string</span> psd_m)  <span class="comment">//传入字符串（psd_m：伪矩阵）</span></span><br><span class="line">&#123;</span><br><span class="line">    m_row = <span class="number">0</span>;   <span class="comment">//行数</span></span><br><span class="line">    m_col = <span class="number">0</span>;   <span class="comment">//列数</span></span><br><span class="line">    <span class="keyword">int</span> col_iter = <span class="number">0</span>;  <span class="comment">//另一个暂时的列数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; iter;  <span class="comment">//因为行数和列数未定，所以用一个向量把读到的数字先存起来</span></span><br><span class="line">    <span class="keyword">int</span> digit_left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> digit_right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">bool</span> in_bracket = <span class="number">0</span>;    <span class="comment">//是否在里层的大括号</span></span><br><span class="line">    <span class="keyword">bool</span> in_bracket_out = <span class="number">0</span>; <span class="comment">//是否在外层的大括号</span></span><br><span class="line">    <span class="keyword">bool</span> is_double = <span class="number">0</span>;     <span class="comment">//是否小数</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;接下来读字符串里面字符（先处理外层大括号）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;psd_m.length();i++) <span class="comment">//一个一个读取字符串的字符</span></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">if</span>(psd_m[i] == <span class="string">' '</span>) <span class="comment">//有空格时忽略</span></span><br><span class="line">           <span class="keyword">continue</span>;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]==<span class="string">'&#123;'</span> &amp;&amp; !in_bracket_out &amp;&amp; !in_bracket)</span><br><span class="line">       <span class="comment">//读到左括号，但是又不在外括号里又不在里括号里，那么这个就是最左边的括号了</span></span><br><span class="line">       &#123;</span><br><span class="line">           in_bracket_out = <span class="number">1</span>;  <span class="comment">//意思是在外层括号里</span></span><br><span class="line">           <span class="keyword">continue</span>; <span class="comment">//任务完成，读取下一个</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]==<span class="string">'&#125;'</span> &amp;&amp; in_bracket_out &amp;&amp; !in_bracket)</span><br><span class="line">       <span class="comment">//读到右括号，在外层括号里且不在里层括号里，那么这个就是最右边的括号了</span></span><br><span class="line">       &#123;</span><br><span class="line">           m_row++; <span class="comment">//行数加一（因为最后一行没有逗号标记）</span></span><br><span class="line"></span><br><span class="line">           in_bracket_out = <span class="number">0</span>; <span class="comment">//意思是不在外层括号里了</span></span><br><span class="line">           <span class="keyword">continue</span>; <span class="comment">//读下一个（我认为这里可以break了，忘记了当时是怎么想的了）</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]==<span class="string">','</span> &amp;&amp; !in_bracket &amp;&amp; in_bracket_out)</span><br><span class="line">       <span class="comment">//读到逗号，在外层括号里，不在里层括号里，这个就是分隔两个里括号的逗号了</span></span><br><span class="line">       &#123;</span><br><span class="line">           m_row++; <span class="comment">//行数加一（不是最后一行的后面都有这个逗号）</span></span><br><span class="line">           <span class="keyword">continue</span>; <span class="comment">//读下一个</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;接着处理里括号与数字（一起来了，有点长）：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(in_bracket_out) <span class="comment">//现在在外括号里面了</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(psd_m[i]==<span class="string">'&#123;'</span> &amp;&amp; !in_bracket)</span><br><span class="line">            <span class="comment">//如果读到左括号且不在里括号里的话，这个就是里括号的最左端，对于矩阵来说是新的一行</span></span><br><span class="line">            &#123;</span><br><span class="line">                in_bracket = <span class="number">1</span>; <span class="comment">//表示在里层括号里</span></span><br><span class="line">                <span class="keyword">continue</span>; <span class="comment">//读下一个</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]==<span class="string">'&#125;'</span> &amp;&amp; in_bracket)</span><br><span class="line">            <span class="comment">//读到右括号且在里括号里，就是里括号的最右端了，</span></span><br><span class="line">            <span class="comment">//这个比较复杂，因为要判断里括号里数字的个数和列数能不能对上</span></span><br><span class="line">            &#123;</span><br><span class="line">                col_iter++; <span class="comment">//暂时存放列数的中间变量加一（这里是最后一个了，其余的在下面处理逗号那一部分里）</span></span><br><span class="line">                <span class="keyword">if</span>(!m_col) m_col = col_iter; <span class="comment">//如果这是列数为0的话（就是第一行了），把这个最终的出来的数（第一行里括号里数字个数）赋给列数</span></span><br><span class="line">                <span class="keyword">if</span>(m_col != col_iter) <span class="comment">//否则如果这个数与列数不相等的话</span></span><br><span class="line">                &#123;</span><br><span class="line">                    error(<span class="number">5</span>); <span class="comment">//报错退出</span></span><br><span class="line">                    <span class="comment">//emm后面的可忽略，因为之前我报错是没退出的。。。</span></span><br><span class="line">                    m_col = <span class="number">0</span>;  </span><br><span class="line">                    m_row = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                col_iter = <span class="number">0</span>;  <span class="comment">//暂时没它的事了，先清零</span></span><br><span class="line"></span><br><span class="line">                iter.push_back(num); <span class="comment">//把得到的数字放进向量里（读数字的操作在下面，这个是这一行的最后一个了）</span></span><br><span class="line">                digit_left = <span class="number">0</span>;  <span class="comment">//清零</span></span><br><span class="line">                digit_right = <span class="number">0</span>; <span class="comment">//清零</span></span><br><span class="line">                is_double = <span class="number">0</span>;   <span class="comment">//清零</span></span><br><span class="line">                num = <span class="number">0</span>;         <span class="comment">//清零</span></span><br><span class="line">                in_bracket = <span class="number">0</span>;  <span class="comment">//意思是已经不在里括号里了</span></span><br><span class="line">                <span class="keyword">continue</span>;  <span class="comment">//读取下一个</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]==<span class="string">','</span> &amp;&amp; in_bracket)</span><br><span class="line">            <span class="comment">//读到逗号，且在里括号里，这个逗号就是用来分隔两个数字的了</span></span><br><span class="line">            &#123;</span><br><span class="line">                col_iter++;  <span class="comment">//暂时存放列数的中间变量加一（与上面那个作用一样）</span></span><br><span class="line"></span><br><span class="line">                iter.push_back(num); <span class="comment">//把得到的数字放进向量里（读数字的操作在下面）</span></span><br><span class="line">                digit_left = <span class="number">0</span>;  <span class="comment">//清零</span></span><br><span class="line">                digit_right = <span class="number">0</span>; <span class="comment">//清零</span></span><br><span class="line">                is_double = <span class="number">0</span>;   <span class="comment">//清零</span></span><br><span class="line">                num = <span class="number">0</span>;         <span class="comment">//清零</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]==<span class="string">'.'</span> &amp;&amp; in_bracket)</span><br><span class="line">            <span class="comment">//读到小数点，在里括号里</span></span><br><span class="line">            &#123;</span><br><span class="line">                is_double = <span class="number">1</span>;  <span class="comment">//标志遇到小数</span></span><br><span class="line">                <span class="keyword">continue</span>;       <span class="comment">//读下一个</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*下面开始处理数字*/</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]&gt;=<span class="string">'0'</span> &amp;&amp; psd_m[i]&lt;=<span class="string">'9'</span> &amp;&amp; in_bracket &amp;&amp; !is_double)</span><br><span class="line">            <span class="comment">//读到0~9的其中一个数，在里括号里且未读到小数点（暂时还是整数）</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> iter_num = (<span class="keyword">int</span>)psd_m[i] - (<span class="keyword">int</span>)<span class="string">'0'</span>; <span class="comment">//字符转数字</span></span><br><span class="line">                num = num*<span class="built_in">pow</span>(<span class="number">10</span>,digit_left) + iter_num; <span class="comment">//接到前面未读完的数的后面（数学问题）</span></span><br><span class="line">                digit_left++; <span class="comment">//小数点左边（整数位数）加一</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(psd_m[i]&gt;=<span class="string">'0'</span> &amp;&amp; psd_m[i]&lt;=<span class="string">'9'</span> &amp;&amp; in_bracket &amp;&amp; is_double)</span><br><span class="line">            <span class="comment">//读到0~9的其中一个数，在里括号里且已经读到小数点（这个是小数了）</span></span><br><span class="line">            &#123;</span><br><span class="line">                digit_right++; <span class="comment">//小数点右边（小数位数）加一(这个顺序问题。。很难解释。。)</span></span><br><span class="line">                <span class="keyword">int</span> iter_num = (<span class="keyword">int</span>)psd_m[i] - (<span class="keyword">int</span>)<span class="string">'0'</span>; <span class="comment">//符号转数字</span></span><br><span class="line">                num = num + iter_num*<span class="built_in">pow</span>(<span class="number">10</span>,(<span class="number">-1</span>)*digit_right); <span class="comment">//接到前面未读完的数的后面（还是数学问题）</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(in_bracket)</span><br><span class="line">            <span class="comment">//上面的都读不到，且在里括号里</span></span><br><span class="line">            &#123;</span><br><span class="line">                error(<span class="number">3</span>); <span class="comment">//报错，退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            <span class="comment">//上面的都读不到，且不在里括号里</span></span><br><span class="line">            &#123;</span><br><span class="line">                error(<span class="number">4</span>); <span class="comment">//报错，退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;最后读到的数都按顺序放在向量里了，把向量里的数放到矩阵里：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">    matrix_p = <span class="keyword">new</span> <span class="keyword">double</span>*[m_row];  <span class="comment">//创建二维数组的老方法了</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;m_row;r++)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix_p[r] = <span class="keyword">new</span> <span class="keyword">double</span>[m_col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;m_col;c++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix_p[r][c] = iter[r*m_col+c]; <span class="comment">//向量的数放进矩阵</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;（ps：上面的代码是可以直接拼在一起的，所以不存在括号不对的情况）</p><h2 id="需求⑤：构造特殊的方阵（比如单位矩阵）"><a href="#需求⑤：构造特殊的方阵（比如单位矩阵）" class="headerlink" title="需求⑤：构造特殊的方阵（比如单位矩阵）"></a>需求⑤：构造特殊的方阵（比如单位矩阵）</h2><p>&emsp;&emsp;如果用上面的方法构造一个100✕100的单位矩阵的话，怕不是要打到手软了，能不能用简单的方法，比如“Matrix I(“I”,100);”？肯定可以啦，先看代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Matrix::Matrix(<span class="built_in">string</span> mark_s,<span class="keyword">int</span> mark_i)  <span class="comment">//参数有两个，前面的是标记的字符，后面的是方阵的大小。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(mark_s==<span class="string">"I"</span>)  <span class="comment">//如果检测到字符是“I”的话，构建一个单位矩阵(我好像忘了判断mark_i是否合理了。。)</span></span><br><span class="line">    &#123;</span><br><span class="line">        m_row = mark_i;  <span class="comment">//方阵的行数和列数相等</span></span><br><span class="line">        m_col = mark_i;</span><br><span class="line"></span><br><span class="line">        matrix_p = <span class="keyword">new</span> <span class="keyword">double</span>*[m_row];  <span class="comment">//同样的方法动态生成二维数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;m_row;r++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix_p[r] = <span class="keyword">new</span> <span class="keyword">double</span>[m_col];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;m_col;c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == r)</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix_p[r][c] = <span class="number">1</span>;  <span class="comment">//对角线上元素为1</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    matrix_p[r][c] = <span class="number">0</span>;  <span class="comment">//其他元素为0</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;这个和前面的类似，就不用多说了，只是漏了判断mark_i是否大于0（现在懒得改- -）。</p><hr><h1 id="复制函数"><a href="#复制函数" class="headerlink" title="复制函数"></a>复制函数</h1><hr><p>&emsp;&emsp;方法类似，逐个元素复制，直接上代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Matrix::Matrix(<span class="keyword">const</span> Matrix &amp;other)</span><br><span class="line">&#123;</span><br><span class="line">    m_row = other.m_row;</span><br><span class="line">    m_col = other.m_col;</span><br><span class="line"></span><br><span class="line">    matrix_p = <span class="keyword">new</span> <span class="keyword">double</span>*[m_row];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;m_row;r++)</span><br><span class="line">    &#123;</span><br><span class="line">        matrix_p[r] = <span class="keyword">new</span> <span class="keyword">double</span>[m_col];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>;c&lt;m_col;c++)</span><br><span class="line">        &#123;</span><br><span class="line">            matrix_p[r][c] = other.matrix_p[r][c];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h1><hr><p>&emsp;&emsp;就是一个个地delete，最后把行数和列数定为0（相当于变为空矩阵），代码：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Matrix::~Matrix()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>;r&lt;m_row;r++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> matrix_p[r];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> matrix_p;</span><br><span class="line">    m_row = <span class="number">0</span>;</span><br><span class="line">    m_col = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><hr><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr><p>&emsp;&emsp;写了这么多，我觉得亮点只有用字符串构造那个（毕竟是我当时突发奇想的，感觉用这个可以写一个脚本了），但是当时是作为复习写的，要求也不可以太高啦。<br>&emsp;&emsp;以上写的效率不一定是最高的，但基本上都是能用的。<br><br><br><br><br>ps：相关链接    ↓<br><br><br>&emsp;&emsp;<a href="https://github.com/ToverPomelo/Class_Matrix" target="_blank" rel="noopener">github上的代码</a><br>&emsp;&emsp;<a href="http://blog.l-tover.xyz/2018/01/08/%E5%86%99%E4%BA%86%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%B1%BB-0/" target="_blank" rel="noopener">写了个矩阵类</a></p>]]></content>
      
      <categories>
          
          <category> Math数学相关 </category>
          
          <category> C\C++编程相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写了个矩阵类</title>
      <link href="/2018/01/08/%E5%86%99%E4%BA%86%E4%B8%AA%E7%9F%A9%E9%98%B5%E7%B1%BB/"/>
      <content type="html"><![CDATA[<p>&emsp;&emsp;本来是为了考试复习写的，后来发现“诶！写的挺好喔（自卖自夸）”，就打算在这里把它写下来。<br><a id="more"></a></p><p>&emsp;&emsp;临近期末时间不多，这里就先把代码贴出来吧：<a href="https://github.com/ToverPomelo/Class_Matrix" target="_blank" rel="noopener">☞戳我☜</a><br><br><br><br><br>ps：相关链接    ↓<br><br><br>&emsp;&emsp;<a href="https://github.com/ToverPomelo/Class_Matrix" target="_blank" rel="noopener">github上的代码</a><br>&emsp;&emsp;<a href="http://blog.l-tover.xyz/2018/01/31/c-%E7%9F%A9%E9%98%B5%E7%B1%BB-%E5%88%9D%E9%98%B6-0/" target="_blank" rel="noopener">c++矩阵类-初阶[0]</a></p>]]></content>
      
      <categories>
          
          <category> Math数学相关 </category>
          
          <category> C\C++编程相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++ </tag>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>克拉默法则的浅谈</title>
      <link href="/2017/12/25/%E5%85%8B%E6%8B%89%E9%BB%98%E6%B3%95%E5%88%99%E7%9A%84%E6%B5%85%E8%B0%88/"/>
      <content type="html"><![CDATA[<p>看懂这个可能需要一点线性代数基本知识。</p><a id="more"></a><h1 id="Cramer’s-Rule能吃吗？"><a href="#Cramer’s-Rule能吃吗？" class="headerlink" title="Cramer’s Rule能吃吗？"></a>Cramer’s Rule能吃吗？</h1><p>&emsp;&emsp;通常来说，我们解一个线性方程组的时候，都会用高斯消元法,因为消元法简单、效率高。但是有没有不借助消元的解法？Cramer’s Rule就是一个例子。</p><h1 id="关键思想-Key-idea"><a href="#关键思想-Key-idea" class="headerlink" title="关键思想(Key idea)"></a>关键思想(Key idea)</h1><p>&emsp;&emsp;我们拿3✕3矩阵来做个栗子：<br>&emsp;&emsp;对于Ax = b ,即：<br>$$<br>\begin{bmatrix}<br>    a_{11} &amp; a_{12} &amp; a_{13} \\<br>    a_{21} &amp; a_{22} &amp; a_{23} \\<br>    a_{31} &amp; a_{32} &amp; a_{33} \\<br>\end{bmatrix}<br>&ensp;<br>\begin{bmatrix}<br>    x_1 \\<br>    x_2 \\<br>    x_3 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>\begin{bmatrix}<br>    b_1 \\<br>    b_2 \\<br>    b_3 \\<br>\end{bmatrix}<br>$$<br>&emsp;&emsp;我们可以拆开为：<br>$$<br>\begin{bmatrix}<br>    A<br>\end{bmatrix}<br>&ensp;<br>\begin{bmatrix}<br>    x_1 &amp; 0 &amp; 0 \\<br>    x_2 &amp; 1 &amp; 0 \\<br>    x_3 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>\begin{bmatrix}<br>    b_1 &amp; a_{12} &amp; a_{13} \\<br>    b_2 &amp; a_{22} &amp; a_{23} \\<br>    b_3 &amp; a_{32} &amp; a_{33} \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>B_1&emsp;&emsp;(1)<br>$$</p><p>$$<br>\begin{bmatrix}<br>    A<br>\end{bmatrix}<br>&ensp;<br>\begin{bmatrix}<br>    1 &amp; x_1 &amp; 0 \\<br>    0 &amp; x_2 &amp; 0 \\<br>    0 &amp; x_3 &amp; 1 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>\begin{bmatrix}<br>    a_{11} &amp; b_1 &amp; a_{13} \\<br>    a_{21} &amp; b_2 &amp; a_{23} \\<br>    a_{31} &amp; b_3 &amp; a_{33} \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>B_2&emsp;&emsp;(2)<br>$$</p><p>$$<br>\begin{bmatrix}<br>    A<br>\end{bmatrix}<br>&ensp;<br>\begin{bmatrix}<br>    1 &amp; 0 &amp; x_1 \\<br>    0 &amp; 1 &amp; x_2 \\<br>    0 &amp; 0 &amp; x_3 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>\begin{bmatrix}<br>    a_{11} &amp; a_{12} &amp; b_1 \\<br>    a_{21} &amp; a_{22} &amp; b_2 \\<br>    a_{31} &amp; a_{32} &amp; b_3 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>B_3&emsp;&emsp;(3)<br>$$</p><h2 id="怎么拆成这样的"><a href="#怎么拆成这样的" class="headerlink" title="怎么拆成这样的?"></a>怎么拆成这样的?</h2><p>&emsp;&emsp;以$(1)$为例，那个 $A$ 右边的矩阵其实就是把单位矩阵 $I$ 中第1列换成 $x$ 。<br>$$<br>\begin{bmatrix}<br>    1 &amp; 0 &amp; 0 \\<br>    0 &amp; 1 &amp; 0 \\<br>    0 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>&ensp;-&gt;&ensp;<br>\begin{bmatrix}<br>    x_1 &amp; 0 &amp; 0 \\<br>    x_2 &amp; 1 &amp; 0 \\<br>    x_3 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>$$<br>&emsp;&emsp;$A$ 与这个矩阵作用后便产生一个新矩阵，不难发现这个矩阵是 $A$ 的第一列替换为 $b$ ,我们把这个新矩阵记作 $B_1$​​ 。<br>$$<br>\begin{bmatrix}<br>    a_{11} &amp; a_{12} &amp; a_{13} \\<br>    a_{21} &amp; a_{22} &amp; a_{23} \\<br>    a_{31} &amp; a_{32} &amp; a_{33} \\<br>\end{bmatrix}<br>&ensp;-&gt;&ensp;<br>\begin{bmatrix}<br>    b_1 &amp; a_{12} &amp; a_{13} \\<br>    b_2 &amp; a_{22} &amp; a_{23} \\<br>    b_3 &amp; a_{32} &amp; a_{33} \\<br>\end{bmatrix}<br>$$<br>&emsp;&emsp;$(2)$和$(3)$的做法与这个类似，只不过$(2)$是替换第二列，$(3)$是替换第三列。</p><h2 id="为什么要这样拆"><a href="#为什么要这样拆" class="headerlink" title="为什么要这样拆"></a>为什么要这样拆</h2><p>&emsp;&emsp;我们来看看它们的行列式(<a href="https://zh.wikipedia.org/wiki/%E8%A1%8C%E5%88%97%E5%BC%8F" target="_blank" rel="noopener">Determinant</a>)吧。<br>&emsp;&emsp;这里要用到行列式乘法:<br>$$<br>detAB = detA × detB<br>$$<br>&emsp;&emsp;如何求行列式这里就不多说了，接下来分析一下上面式子的行列式：（这么多 0 用<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E5%BC%8F%E5%92%8C%E4%BD%99%E5%AD%90%E5%BC%8F" target="_blank" rel="noopener">余子式</a>算就好啦）</p><p>$$<br>det&ensp;<br>\begin{bmatrix}<br>    x_1 &amp; 0 &amp; 0 \\<br>    x_2 &amp; 1 &amp; 0 \\<br>    x_3 &amp; 0 &amp; 1 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>x_1<br>$$</p><p>$$<br>det&ensp;<br>\begin{bmatrix}<br>    1 &amp; x_1 &amp; 0 \\<br>    0 &amp; x_2 &amp; 0 \\<br>    0 &amp; x_3 &amp; 1 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>x_2<br>$$</p><p>$$<br>det&ensp;<br>\begin{bmatrix}<br>    1 &amp; 0 &amp; x_1 \\<br>    0 &amp; 1 &amp; x_2 \\<br>    0 &amp; 0 &amp; x_3 \\<br>\end{bmatrix}<br>&ensp;=&ensp;<br>x_3<br>$$<br>&emsp;&emsp;两边求行列式便可以得到：</p><p>$$<br>(detA)(x_1) = detB_1<br>$$</p><p>$$<br>(detA)(x_2) = detB_2<br>$$</p><p>$$<br>(detA)(x_3) = detB_3<br>$$<br>&emsp;&emsp;两边除以 $detA$ 就可以求出向量 $x$ 中的每一个数：</p><p>$$<br>x_1 = detB_1/detA<br>$$</p><p>$$<br>x_2 = detB_2/detA<br>$$</p><p>$$<br>x_3 = detB_3/detA<br>$$<br>&emsp;&emsp;也就是说 $x = \begin{bmatrix} detB_1/detA \\ detB_2/detA \\ detB_3/detA \\ \end{bmatrix} $<br>&emsp;&emsp;当然，可以这样子操作的前提是detAdetA ≠ 0,分母不能为0。</p><blockquote><p>&emsp;&emsp;  网上对$detA=0$时的情况说得不多（大多都是说这是前提条件），本来打算略过的，但想想还是可以稍微谈一下的，因为如果$detA=0$的话，$detBi=0$ 对于任意$i=1,2,…,n$都成立。<br>&emsp;&emsp;如果$detA=0$的话，$A$就是<a href="https://baike.baidu.com/item/%E5%A5%87%E5%BC%82%E7%9F%A9%E9%98%B5" target="_blank" rel="noopener">奇异矩阵</a>了，$A$是奇异矩阵的话就说明存在一组不全为零的 $α_1 α_2 …α_n$ 使得<br>$$<br>α_1a_1 + α_2a_2 + … + α_na_n = 0 &emsp;&emsp; (∗)<br>$$<br>&emsp;&emsp;这里的$ai(i=1,2,…,n)$是$A$的各列，下面也是，顺便引用一下<a href="https://baike.baidu.com/item/%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3" target="_blank" rel="noopener">百度百科</a>的说法<br>&emsp;&emsp;由于$Ax=b$，所以有<br>$$<br>x_1a_1 + x_2a_2 + … + x_na_n = b<br>$$<br>&emsp;&emsp;（注意这里的$xi(i=1,2,…,n)$是数不是向量），那么当 $A$ 的第 $i$ 列被 $b$ 替换时，就有<br>$$<br>[a_1 … a_i−1 &ensp; b &ensp; a_i+1 …a_n]<br>$$<br>&emsp;&emsp;把 $b$ 代进去就有<br>$$<br>[a_1 … (x_1a_1 + x_2a_2 + … + x_na_n) … a_n]<br>$$<br>记这个矩阵为 $Bi$ 吧，接下来要说明 $Bi$ 也是奇异矩阵（$detBi=0$）,同样，如果 $Bi$ 为奇异矩阵的话，就是存在一组不全为零的 $β_1 β_2 … β_n$ 使得<br>$$<br>β_1a_1 + … + β_i(x_1a_1+…+x_na_n) + … + β_na_n = 0<br>$$<br>&emsp;&emsp;太乱了化简一下（这里因为位置问题省略了很多字母。。。机智的你应该可以看得懂的！）<br>$$<br>(β_ix_1 + β_1)a_1 + … + (β_ix_n + β_n)a_n = 0 &emsp;&emsp; (∗∗)<br>$$<br>&emsp;&emsp;所以可以看出如果<br>$$<br>β_ix_j + β_j = α_j &emsp; (j=1,2,…,n)<br>$$<br>&emsp;&emsp;的话，式子 $(∗∗)$ 就等同于式子 $(∗)$ 了，也就是式子 $(∗∗)$ 是成立的。<br>&emsp;&emsp;也就是说当 $detA=0$ 时，$detBi=0$ ，就有 $0✕x = 0$ ,这也说明了当 $A$ 为奇异矩阵时，$x$ 的解不唯一。</p><hr><p>&emsp;&emsp;作者：“上面的就是一派胡言!”</p></blockquote><h1 id="如何解一个矩阵？"><a href="#如何解一个矩阵？" class="headerlink" title="如何解一个矩阵？"></a>如何解一个矩阵？</h1><p>&emsp;&emsp;注意，上面解出来的 $x$ 只是一个向量，那如何解一个矩阵？比如 $AB=C$ 。<br>&emsp;&emsp;这时我们可以把矩阵 $B$ 拆开：(注意这里$b_n$和$c_n$为向量)<br>$$<br>A &ensp; [b_1 &ensp; b_2 &ensp; … &ensp; b_n] &ensp; = &ensp; [c_1 &ensp; c_2 &ensp; … &ensp; c_n]<br>$$<br>&emsp;&emsp;于是：<br>$$<br>Ab_​i &ensp; = &ensp; c_i  &emsp; (i=1,2,…,n)<br>$$<br>&emsp;&emsp;这样就把一个矩阵拆成若干个向量，剩下的就与上面类似。</p><h1 id="一个应用：求逆"><a href="#一个应用：求逆" class="headerlink" title="一个应用：求逆"></a>一个应用：求逆</h1><p>&emsp;&emsp;我们可以用克拉默法则求逆，其实就是求 $AA^{−1}=I$ ,于是这样这样那样那样，就得到：<br>$$<br>A^{-1}<br>&ensp;=&ensp;<br>\frac{C^T}{detA} \quad<br>$$<br>&emsp;&emsp;（$C$ 是 $A$ 的<a href="https://zh.wikipedia.org/wiki/%E9%A4%98%E5%9B%A0%E5%AD%90%E7%9F%A9%E9%99%A3" target="_blank" rel="noopener">代数余子式矩阵</a>）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;虽然克拉默法则看起来很酷，但是其效率并不高（比消元慢多了），起码求行列式的一个较快的方法就是消元。</p><hr><p>&emsp;&emsp;另外，本文作者很水的，上面说的有错也不奇怪。有什么问题欢迎在评论区留言。</p>]]></content>
      
      <categories>
          
          <category> Math数学相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World!</title>
      <link href="/2017/12/24/Hello-World/"/>
      <content type="html"><![CDATA[<p>按照惯例，通常都是从”Hello World!”开始的，所以，<a id="more"></a>上代码：</p><h1 id="c版本代码"><a href="#c版本代码" class="headerlink" title="c版本代码"></a>c版本代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 14</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">font_rand</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">char</span> word[NUM]=<span class="string">"Hello World!"</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n\t"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;NUM;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        font_rand();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,word[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\e[0m"</span><span class="string">"\n\n"</span>); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">font_rand</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(rand()%<span class="number">16</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;30m"</span>); <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;31m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;32m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;33m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;34m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;35m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;36m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:<span class="built_in">printf</span>(<span class="string">"\e[01;37m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;30m"</span>); <span class="keyword">break</span>; </span><br><span class="line">        <span class="keyword">case</span> <span class="number">9</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;31m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">10</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;32m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">11</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;33m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">12</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;34m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">13</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;35m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">14</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;36m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">15</span>:<span class="built_in">printf</span>(<span class="string">"\e[00;37m"</span>); <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><p>&emsp;&emsp;就是通过转移字符改变字体的颜色。 <br><br>&emsp;&emsp;先把字符串存进数组“word”中，通过函数“font_rand()”随机选取一种颜色，然后每改变一次颜色打印“word”中一个字符，最后把颜色改为白色。（Terminal的字体颜色） <br><br>&emsp;&emsp;测试环境: Ubuntu 17.10 <br><br><figure class="image-box">                <img src="deemo.png" alt="" title="" class="">                <p></p>            </figure></p>]]></content>
      
      <categories>
          
          <category> C\C++编程相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>从零到壹</title>
      <link href="/2017/12/23/%E4%BB%8E%E9%9B%B6%E5%88%B0%E5%A3%B9/"/>
      <content type="html"><![CDATA[<h1 id="从零开始"><a href="#从零开始" class="headerlink" title="从零开始"></a>从零开始</h1><a id="more"></a><ul><li><del><a href="https://wanwang.aliyun.com/" target="_blank" rel="noopener">被广告坑到万网买了个域名</a></del><br>（因为某些原因，旧的域名被阿*云“暂停”了，不想去搞BA的我只好在<a href="https://sg.godaddy.com/zh/" target="_blank" rel="noopener">godaddy</a>重新买了个域名）</li><li><a href="https://www.jianshu.com/p/71f0d6bf6d2f" target="_blank" rel="noopener">参考了一篇简书</a></li><li><a href="https://www.google.com/" target="_blank" rel="noopener">途中不断地谷歌</a></li><li><a href="https://github.com/codefine/hexo-theme-mellow" target="_blank" rel="noopener">最后偷了Michael.Lu的主题</a></li></ul><hr><h1 id="新的博客终于建成了📣📣📣"><a href="#新的博客终于建成了📣📣📣" class="headerlink" title="新的博客终于建成了📣📣📣"></a>新的博客终于建成了📣📣📣</h1><hr>]]></content>
      
      <categories>
          
          <category> 与编程无关 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
